"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const xmlbuilder_1 = require("xmlbuilder");
const readline_1 = require("readline");
const os_1 = require("os");
const stream_1 = require("stream");
const nameRegex = /script: (.*)$/m;
function parseLine(line) {
    const threshold = /([✓|✗]) (.*?)\.+:/g.exec(line);
    if (threshold && threshold.length > 2) {
        return {
            systemOut: line,
            passed: threshold[1] === "✓",
            name: threshold[2]
        };
    }
    return null;
}
exports.parseLine = parseLine;
function parseName(line) {
    const name = nameRegex.exec(line);
    return name && name[1];
}
exports.parseName = parseName;
/**
 * https://llg.cubic.org/docs/junit/
 * https://dzone.com/articles/viewing-junit-xml-files-locally
 *
 */
function toXml(testsuites, stream) {
    const xmlObj = xmlbuilder_1.create("testsuites");
    xmlObj.att("tests", testsuites.reduce((acc, ts) => acc + ts.thresholds.length, 0));
    xmlObj.att("failures", testsuites.reduce((acc, ts) => acc + ts.thresholds.filter(th => !th.passed).length, 0));
    const firstStart = Math.min(...testsuites.map(ts => ts.startTime).filter(Boolean));
    const lastEnd = Math.max(...testsuites.map(ts => ts.endTime).filter(Boolean));
    if (Number.isSafeInteger(lastEnd - firstStart)) {
        xmlObj.att("time", (lastEnd - firstStart) / 1000);
    }
    testsuites.forEach(testsuite => {
        const suiteEle = xmlObj.ele("testsuite");
        suiteEle.att("name", testsuite.name);
        suiteEle.att("tests", testsuite.thresholds.length);
        suiteEle.att("failures", testsuite.thresholds.filter(res => !res.passed).length);
        if (testsuite.startTime) {
            const endTime = testsuite.endTime || Date.now();
            suiteEle.att("time", (endTime - testsuite.startTime) / 1000);
            suiteEle.att("timestamp", new Date(testsuite.startTime).toISOString());
        }
        testsuite.thresholds.forEach(threshold => {
            const testcase = suiteEle.ele("testcase", { name: threshold.name });
            if (!threshold.passed) {
                testcase.ele("failure", { message: threshold.systemOut }, threshold.systemOut);
            }
            if (threshold.systemOut) {
                testcase.ele("system-out", {}, threshold.systemOut);
            }
        });
        if (testsuite.stdout) {
            suiteEle.ele("system-out").cdata(testsuite.stdout);
        }
    });
    return xmlObj.end(stream ? xmlbuilder_1.streamWriter(stream, { pretty: true }) : { pretty: true });
}
exports.toXml = toXml;
class K6Parser {
    constructor() {
        this._testSuites = [];
    }
    parse(input, options) {
        const inputStream = new stream_1.Readable();
        const promise = this.pipeFrom(inputStream, options);
        inputStream.push(input);
        inputStream.push(null);
        return promise;
    }
    pipeFrom(input, options) {
        let testSuite;
        const reset = () => {
            testSuite = {
                name: options && options.name,
                startTime: options && options.startTime,
                stdout: "",
                thresholds: []
            };
        };
        reset();
        const finalise = () => {
            if (testSuite.name) {
                const result = {
                    name: testSuite.name,
                    thresholds: testSuite.thresholds,
                    startTime: testSuite.startTime,
                    endTime: (options && options.endTime) || Date.now(),
                    stdout: testSuite.stdout
                };
                this._testSuites.push(result);
            }
        };
        const rl = readline_1.createInterface({ input, output: options && options.output });
        rl.on("line", line => {
            if (!testSuite.startTime) {
                testSuite.startTime = Date.now();
            }
            testSuite.stdout += line + os_1.EOL;
            const result = parseLine(line);
            if (result) {
                testSuite.thresholds.push(result);
            }
            if (!testSuite.name) {
                const name = parseName(line);
                if (name) {
                    testSuite.name = name;
                }
            }
            if (/vus_max.*$/gm.test(line)) {
                finalise();
                reset();
            }
        });
        return new Promise((res, rej) => {
            rl.on("close", () => {
                finalise();
                res();
            });
            rl.on("SIGINT", () => {
                rej();
            });
        });
    }
    getTestSuites() {
        return this._testSuites;
    }
    allPassed() {
        return this._testSuites.every(ts => ts.thresholds.every(th => th.passed));
    }
    toXml(stream) {
        return toXml(this._testSuites, stream);
    }
}
exports.K6Parser = K6Parser;
exports.default = K6Parser;
//# sourceMappingURL=index.js.map